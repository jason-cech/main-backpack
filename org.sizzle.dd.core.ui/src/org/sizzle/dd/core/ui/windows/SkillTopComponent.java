/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.sizzle.dd.core.ui.windows;

import java.beans.IntrospectionException;
import java.util.Collection;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.logging.Logger;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.ExplorerUtils;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.BeanNode;
import org.openide.nodes.ChildFactory;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;
import org.sizzle.dd.core.Avatar;
import org.sizzle.dd.core.modifier.TrainedSkillModifier;
import org.sizzle.dd.core.skills.CoreSkillProperty;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
				dtd = "-//org.sizzle.dd.core.ui.windows//Skill//EN",
				autostore = false)
@TopComponent.Description(
				preferredID = "SkillTopComponent",
				//iconBase="SET/PATH/TO/ICON/HERE", 
				persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "explorer", openAtStartup = false)
@ActionID(category = "Window", id = "org.sizzle.dd.core.ui.windows.SkillTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
				displayName = "#CTL_SkillAction",
				preferredID = "SkillTopComponent")
@Messages({
	"CTL_SkillAction=Skill",
	"CTL_SkillTopComponent=Skill Window",
	"HINT_SkillTopComponent=This is a Skill window"
})
public final class SkillTopComponent extends TopComponent implements ExplorerManager.Provider {

	private final ExplorerManager explorerManager = new ExplorerManager();
	private SkillChildFactory skillChildFactory = null;
	
	public SkillTopComponent() {
		initComponents();
		setName(Bundle.CTL_SkillTopComponent());
		setToolTipText(Bundle.HINT_SkillTopComponent());

		associateLookup(ExplorerUtils.createLookup(explorerManager, getActionMap()));
	}

	/**
	 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
	 * content of this method is always regenerated by the Form Editor.
	 */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    outlineView1 = new org.openide.explorer.view.OutlineView("Skill");

    setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.LINE_AXIS));
    add(outlineView1);
  }// </editor-fold>//GEN-END:initComponents
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private org.openide.explorer.view.OutlineView outlineView1;
  // End of variables declaration//GEN-END:variables

	@Override
	public void componentOpened() {
		Avatar avatar = Lookup.getDefault().lookup(Avatar.class);
		if (null == skillChildFactory) 
			skillChildFactory = new SkillChildFactory(avatar);

		Children children = Children.create(skillChildFactory, true);

		// Create a root node
		Node rootNode = new AbstractNode(children);

		outlineView1.setPropertyColumns("score", "Score", "trained", "Trained");

		// Hide the root node
		outlineView1.getOutline().setRootVisible(false);

		explorerManager.setRootContext(rootNode);
	}

	@Override
	public void componentClosed() {
		skillChildFactory = null;
	}

	void writeProperties(java.util.Properties p) {
		// better to version settings since initial version as advocated at
		// http://wiki.apidesign.org/wiki/PropertyFiles
		p.setProperty("version", "1.0");
	}

	void readProperties(java.util.Properties p) {
		String version = p.getProperty("version");
	}

	@Override
	public ExplorerManager getExplorerManager() {
		return explorerManager;
	}

	public class Skill {

		String name;
		Integer score;
		Boolean trained;

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public Integer getScore() {
			return score;
		}

		public void setScore(Integer score) {
			this.score = score;
		}

		public Boolean getTrained() {
			return trained;
		}

		public void setTrained(Boolean trained) {
			this.trained = trained;
		}
	}

	public class SkillNode extends BeanNode<Skill> {

		public SkillNode(Skill bean) throws IntrospectionException {
			super(bean);
			setDisplayName(bean.getName());
			setShortDescription("Hahahaaahaa");
		}
	}

	public class SkillChildFactory extends ChildFactory<Skill> implements Observer {

		private final Avatar avatar;
		private final Collection<? extends CoreSkillProperty> skillProperties;

		public SkillChildFactory(Avatar avatar) {
			this.avatar = avatar;
			skillProperties = avatar.getLookup().lookupAll(CoreSkillProperty.class);
			
			attachToSkillProperties();
		}
		
		private void attachToSkillProperties() {
			for (CoreSkillProperty<?> skillProperty : skillProperties) {
				skillProperty.addObserver(this);
			}
		}

		@Override
		protected boolean createKeys(List<Skill> toPopulate) {
			for (CoreSkillProperty<?> skillProperty : skillProperties) {
				Skill skill = new Skill();
				skill.setName(skillProperty.getClass().getSimpleName().replace("Skill", ""));
				if (skillProperty.getValue().getClass().isInstance(Integer.class))
					skill.setScore(Integer.class.cast(skillProperty.getValue()));
				else
					Logger.getLogger(SkillChildFactory.class.getName()).warning("WTF Creating SkillChild Keys");
				
				TrainedSkillModifier trainedSkillModifier = skillProperty.getLookup().lookup(TrainedSkillModifier.class);
				skill.setTrained((null != trainedSkillModifier && trainedSkillModifier.isEnabled(avatar)));

				toPopulate.add(skill);
			}

			return true;
		}

		@Override
		protected Node createNodeForKey(Skill key) {
			SkillNode node = null;
			try {
				node = new SkillNode(key);
			} catch (IntrospectionException e) {
				Exceptions.printStackTrace(e);
			}
			return node;
		}

		@Override
		public void update(Observable o, Object arg) {
			this.refresh(true);
		}
	}
}
